version: 2.0.{build}
branches:
  only:
  - master
image: Visual Studio 2015
init:
- ps: "Function Get-IniContent {  \n    <#  \n    .Synopsis  \n        Gets the content of an INI file  \n          \n    .Description  \n        Gets the content of an INI file and returns it as a hashtable  \n          \n    .Notes  \n        Author        : Oliver Lipkau <oliver@lipkau.net>  \n        Blog        : http://oliver.lipkau.net/blog/  \n        Source        : https://github.com/lipkau/PsIni \n                      http://gallery.technet.microsoft.com/scriptcenter/ea40c1ef-c856-434b-b8fb-ebd7a76e8d91 \n        Version        : 1.0 - 2010/03/12 - Initial release  \n                      1.1 - 2014/12/11 - Typo (Thx SLDR) \n                                         Typo (Thx Dave Stiff) \n          \n        #Requires -Version 2.0  \n          \n    .Inputs  \n        System.String  \n          \n    .Outputs  \n        System.Collections.Hashtable  \n          \n    .Parameter FilePath  \n        Specifies the path to the input file.  \n          \n    .Example  \n        $FileContent = Get-IniContent \"C:\\myinifile.ini\"  \n        -----------  \n        Description  \n        Saves the content of the c:\\myinifile.ini in a hashtable called $FileContent  \n      \n    .Example  \n        $inifilepath | $FileContent = Get-IniContent  \n        -----------  \n        Description  \n        Gets the content of the ini file passed through the pipe into a hashtable called $FileContent  \n      \n    .Example  \n        C:\\PS>$FileContent = Get-IniContent \"c:\\settings.ini\"  \n        C:\\PS>$FileContent[\"Section\"][\"Key\"]  \n        -----------  \n        Description  \n        Returns the key \"Key\" of the section \"Section\" from the C:\\settings.ini file  \n          \n    .Link  \n        Out-IniFile  \n    #>  \n      \n    [CmdletBinding()]  \n    Param(  \n        [ValidateNotNullOrEmpty()]  \n        [ValidateScript({(Test-Path $_) -and ((Get-Item $_).Extension -eq \".ini\")})]  \n        [Parameter(ValueFromPipeline=$True,Mandatory=$True)]  \n        [string]$FilePath  \n    )  \n      \n    Begin  \n        {Write-Verbose \"$($MyInvocation.MyCommand.Name):: Function started\"}  \n          \n    Process  \n    {  \n        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Processing file: $Filepath\"  \n              \n        $ini = @{}  \n        switch -regex -file $FilePath  \n        {  \n            \"^\\[(.+)\\]$\" # Section  \n            {  \n                $section = $matches[1]  \n                $ini[$section] = @{}  \n                $CommentCount = 0  \n            }  \n            \"^(;.*)$\" # Comment  \n            {  \n                if (!($section))  \n                {  \n                    $section = \"No-Section\"  \n                    $ini[$section] = @{}  \n                }  \n                $value = $matches[1]  \n                $CommentCount = $CommentCount + 1  \n                $name = \"Comment\" + $CommentCount  \n                $ini[$section][$name] = $value  \n            }   \n            \"(.+?)\\s*=\\s*(.*)\" # Key  \n            {  \n                if (!($section))  \n                {  \n                    $section = \"No-Section\"  \n                    $ini[$section] = @{}  \n                }  \n                $name,$value = $matches[1..2]  \n                $ini[$section][$name] = $value  \n            }  \n        }  \n        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Finished Processing file: $FilePath\"  \n        Return $ini  \n    }  \n          \n    End  \n        {Write-Verbose \"$($MyInvocation.MyCommand.Name):: Function ended\"}  \n} \n\nFunction Out-IniFile {  \n    <#  \n    .Synopsis  \n        Write hash content to INI file  \n          \n    .Description  \n        Write hash content to INI file  \n          \n    .Notes  \n        Author        : Oliver Lipkau <oliver@lipkau.net>  \n        Blog        : http://oliver.lipkau.net/blog/  \n        Source        : https://github.com/lipkau/PsIni \n                      http://gallery.technet.microsoft.com/scriptcenter/ea40c1ef-c856-434b-b8fb-ebd7a76e8d91 \n        Version        : 1.0 - 2010/03/12 - Initial release  \n                      1.1 - 2012/04/19 - Bugfix/Added example to help (Thx Ingmar Verheij)  \n                      1.2 - 2014/12/11 - Improved handling for missing output file (Thx SLDR) \n          \n        #Requires -Version 2.0  \n          \n    .Inputs  \n        System.String  \n        System.Collections.Hashtable  \n          \n    .Outputs  \n        System.IO.FileSystemInfo  \n          \n    .Parameter Append  \n        Adds the output to the end of an existing file, instead of replacing the file contents.  \n          \n    .Parameter InputObject  \n        Specifies the Hashtable to be written to the file. Enter a variable that contains the objects or type a command or expression that gets the objects.  \n  \n    .Parameter FilePath  \n        Specifies the path to the output file.  \n       \n     .Parameter Encoding  \n        Specifies the type of character encoding used in the file. Valid values are \"Unicode\", \"UTF7\",  \n         \"UTF8\", \"UTF32\", \"ASCII\", \"BigEndianUnicode\", \"Default\", and \"OEM\". \"Unicode\" is the default.  \n          \n        \"Default\" uses the encoding of the system's current ANSI code page.   \n          \n        \"OEM\" uses the current original equipment manufacturer code page identifier for the operating   \n        system.  \n       \n     .Parameter Force  \n        Allows the cmdlet to overwrite an existing read-only file. Even using the Force parameter, the cmdlet cannot override security restrictions.  \n          \n     .Parameter PassThru  \n        Passes an object representing the location to the pipeline. By default, this cmdlet does not generate any output.  \n                  \n    .Example  \n        Out-IniFile $IniVar \"C:\\myinifile.ini\"  \n        -----------  \n        Description  \n        Saves the content of the $IniVar Hashtable to the INI File c:\\myinifile.ini  \n          \n    .Example  \n        $IniVar | Out-IniFile \"C:\\myinifile.ini\" -Force  \n        -----------  \n        Description  \n        Saves the content of the $IniVar Hashtable to the INI File c:\\myinifile.ini and overwrites the file if it is already present  \n          \n    .Example  \n        $file = Out-IniFile $IniVar \"C:\\myinifile.ini\" -PassThru  \n        -----------  \n        Description  \n        Saves the content of the $IniVar Hashtable to the INI File c:\\myinifile.ini and saves the file into $file  \n  \n    .Example  \n        $Category1 = @{“Key1”=”Value1”;”Key2”=”Value2”}  \n    $Category2 = @{“Key1”=”Value1”;”Key2”=”Value2”}  \n    $NewINIContent = @{“Category1”=$Category1;”Category2”=$Category2}  \n    Out-IniFile -InputObject $NewINIContent -FilePath \"C:\\MyNewFile.INI\"  \n        -----------  \n        Description  \n        Creating a custom Hashtable and saving it to C:\\MyNewFile.INI  \n    .Link  \n        Get-IniContent  \n    #>  \n      \n    [CmdletBinding()]  \n    Param(  \n        [switch]$Append,  \n          \n        [ValidateSet(\"Unicode\",\"UTF7\",\"UTF8\",\"UTF32\",\"ASCII\",\"BigEndianUnicode\",\"Default\",\"OEM\")]  \n        [Parameter()]  \n        [string]$Encoding = \"Unicode\",  \n \n          \n        [ValidateNotNullOrEmpty()]  \n        [ValidatePattern('^([a-zA-Z]\\:)?.+\\.ini$')]  \n        [Parameter(Mandatory=$True)]  \n        [string]$FilePath,  \n          \n        [switch]$Force,  \n          \n        [ValidateNotNullOrEmpty()]  \n        [Parameter(ValueFromPipeline=$True,Mandatory=$True)]  \n        [Hashtable]$InputObject,  \n          \n        [switch]$Passthru  \n    )  \n      \n    Begin  \n        {Write-Verbose \"$($MyInvocation.MyCommand.Name):: Function started\"}  \n          \n    Process  \n    {  \n        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Writing to file: $Filepath\"  \n          \n        if ($append) {$outfile = Get-Item $FilePath}  \n        else {$outFile = New-Item -ItemType file -Path $Filepath -Force:$Force}  \n        if (!($outFile)) {Throw \"Could not create File\"}  \n        foreach ($i in $InputObject.keys)  \n        {  \n            if (!($($InputObject[$i].GetType().Name) -eq \"Hashtable\"))  \n            {  \n                #No Sections  \n                Write-Verbose \"$($MyInvocation.MyCommand.Name):: Writing key: $i\"  \n                Add-Content -Path $outFile -Value \"$i=$($InputObject[$i])\" -Encoding $Encoding  \n            } else {  \n                #Sections  \n                Write-Verbose \"$($MyInvocation.MyCommand.Name):: Writing Section: [$i]\"  \n                Add-Content -Path $outFile -Value \"[$i]\" -Encoding $Encoding  \n                Foreach ($j in $($InputObject[$i].keys | Sort-Object))  \n                {  \n                    if ($j -match \"^Comment[\\d]+\") {  \n                        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Writing comment: $j\"  \n                        Add-Content -Path $outFile -Value \"$($InputObject[$i][$j])\" -Encoding $Encoding  \n                    } else {  \n                        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Writing key: $j\"  \n                        Add-Content -Path $outFile -Value \"$j=$($InputObject[$i][$j])\" -Encoding $Encoding  \n                    }  \n                      \n                }  \n                Add-Content -Path $outFile -Value \"\" -Encoding $Encoding  \n            }  \n        }  \n        Write-Verbose \"$($MyInvocation.MyCommand.Name):: Finished Writing to file: $path\"  \n        if ($PassThru) {Return $outFile}  \n    }  \n          \n    End  \n        {Write-Verbose \"$($MyInvocation.MyCommand.Name):: Function ended\"}  \n}\n\n# Allow Remote Desktop\n$blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n\n# Microsoft Visual Studio 2013 Coded UI Test Plugin for Silverlight\n$msiFilePath = \"$($env:USERPROFILE)\\UITestPluginForSilverlightVS2013.msi\"\n$logFilePath = \"$($env:TEMP)\\UITestPluginForSilverlightVS2013.txt\"\n(New-Object Net.WebClient).DownloadFile('https://visualstudiogallery.msdn.microsoft.com/51b4a94a-1878-4dcc-81e0-7dc92131d2da/file/133666/1/UITestPluginForSilverlightVS2013.msi', $msiFilePath)\n$process = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i $msiFilePath /quiet /l*v $logFilePath\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  Get-Content $logFilePath\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $msiFilePath\ndel $logFilePath\nWrite-Host \"Visual Studio 2013 Coded UI Test Plugin for Silverlight successfully installed\" -ForegroundColor Green\n\n# Microsoft Visual Studio 2015 Coded UI Test Plugin for Silverlight\n$msiFilePath = \"$($env:USERPROFILE)\\UITestPluginForSilverlightVS2015.msi\"\n$logFilePath = \"$($env:TEMP)\\UITestPluginForSilverlightVS2015.txt\"\n(New-Object Net.WebClient).DownloadFile('https://visualstudiogallery.msdn.microsoft.com/bf0caedc-90eb-46af-9c1a-8e68d013bb99/file/189320/1/UITestPluginForSilverlightVS2015.msi', $msiFilePath)\n$process = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i $msiFilePath /quiet /l*v $logFilePath\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  Get-Content $logFilePath\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $msiFilePath\ndel $logFilePath\nWrite-Host \"Visual Studio 2015 Coded UI Test Plugin for Silverlight successfully installed\" -ForegroundColor Green\n\n\n# Microsoft Silverlight 5 Toolkit - December 2011\n$msiFilePath = \"$($env:USERPROFILE)\\Silverlight_5_Toolkit_December_2011.msi\"\n$logFilePath = \"$($env:TEMP)\\Silverlight_5_Toolkit_December_2011.txt\"\n(New-Object Net.WebClient).DownloadFile('http://download-codeplex.sec.s-msft.com/Download/Release?ProjectName=silverlight&DownloadId=311823&FileTime=129679336571930000&Build=21031', $msiFilePath)\n$process = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i $msiFilePath /quiet /l*v $logFilePath\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  Get-Content $logFilePath\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $msiFilePath\ndel $logFilePath\nWrite-Host \"Microsoft Silverlight 5 Toolkit - December 2011 successfully installed\" -ForegroundColor Green\n\n# Google Chrome\n$msiFilePath = \"$($env:USERPROFILE)\\GoogleChromeStandaloneEnterprise.msi\"\n$logFilePath = \"$($env:TEMP)\\GoogleChromeStandaloneEnterprise.txt\"\n(New-Object Net.WebClient).DownloadFile('https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7B7ACD904C-E309-ADA4-8671-783B10D723FD%7D%26lang%3Den%26browser%3D4%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers/edgedl/chrome/install/GoogleChromeStandaloneEnterprise.msi', $msiFilePath)\n$process = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i $msiFilePath /quiet /l*v $logFilePath\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  Get-Content $logFilePath\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $msiFilePath\ndel $logFilePath\nWrite-Host \"Google Chrome successfully installed\" -ForegroundColor Green\n\n# Mozilla Firefox 27.0.1\n$exeFilePath = \"$($env:USERPROFILE)\\Firefox Setup 27.0.1.exe\"\n(New-Object Net.WebClient).DownloadFile('http://ftp.mozilla.org/pub/mozilla.org/firefox/releases/27.0.1/win32/es-ES/Firefox%20Setup%2027.0.1.exe', $exeFilePath)\n$process = (Start-Process -FilePath $exeFilePath -ArgumentList \"-ms\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $exeFilePath\nWrite-Host \"Mozilla Firefox 27.0.1 successfully installed\" -ForegroundColor Green\n\n# Disable Firefox First Run Import Settings and Data Wizard\n$ProgramFiles = ${Env:ProgramFiles(x86)}\n$FilePath = $ProgramFiles + \"\\Mozilla Firefox\\override.ini\"\nif (!(test-path ($FilePath)))\n{\n  # create the override.ini per https://developer.mozilla.org/en/Command_Line_Options\n  $err=@()\n  New-Item -type file -force $FilePath -ErrorVariable err | Out-Null\n  if (!($err.count -eq 0))\n  {\n    throw \"Failed to create override.ini.\"\n  }\n}\n\n# read in the override.ini file\n$iniData = Get-IniContent $FilePath\n\nif (!($iniData.XRE))\n{\n  $iniData.XRE = @{}\n}\n\nif (!($iniData.XRE.EnableProfileMigrator -eq 0))\n{\n  $iniData.XRE.EnableProfileMigrator = 0\n  Out-IniFile -InputObject $iniData -FilePath $FilePath -Append\n}\nWrite-Host \"Mozilla Firefox Profile Migrator disabled\" -ForegroundColor Green\n\n# Selenium components for Coded UI Cross Browser Testing\n$msiFilePath = \"$($env:USERPROFILE)\\CodedUITestCrossBrowserSetup.msi\"\n$logFilePath = \"$($env:TEMP)\\CodedUITestCrossBrowserSetup.txt\"\n(New-Object Net.WebClient).DownloadFile('https://visualstudiogallery.msdn.microsoft.com/11cfc881-f8c9-4f96-b303-a2780156628d/file/85444/12/CodedUITestCrossBrowserSetup.msi', $msiFilePath)\n$process = (Start-Process -FilePath \"msiexec.exe\" -ArgumentList \"/i $msiFilePath /quiet /l*v $logFilePath\" -Wait -Passthru)\n$exitCode = $process.ExitCode\nif ($exitCode -ne 0)\n{\n  Get-Content $logFilePath\n  throw \"Command failed with exit code $exitCode.\"\n}\ndel $msiFilePath\ndel $logFilePath\nWrite-Host \"Selenium components for Coded UI Cross Browser Testing successfully installed\" -ForegroundColor Green\n\nif(-not $screen_resolution) {\n  $screen_resolution = '1024x768'\n}\n\nWrite-Host \"Setting up active Desktop...\" -ForegroundColor cyan\n# https://github.com/FreeRDP/FreeRDP/wiki/CommandLineInterface\n#$zipPath = \"$($env:USERPROFILE)\\wfreerdp-1.1.zip\"\n#(New-Object Net.WebClient).DownloadFile('http://av1southus4workers.blob.core.windows.net/downloads/tools/wfreerdp-1.1.zip', $zipPath)\n#7z x $zipPath -y -o\"$env:TEMP\" | Out-Null\n#Write-Host \"Starting Remote Desktop session...\"\n#$psw = (get-itemproperty -path 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' -name DefaultPassword).DefaultPassword\n#Start-Process \"$env:TEMP\\wfreerdp.exe\" -ArgumentList '/v:127.0.0.1','/u:appveyor',\"/p:$psw\",\"/size:$screen_resolution\" -WindowStyle Hidden\n#Write-Host \"Waiting for RDP to connect...\"\n#Start-Sleep -s 5\n#Write-Host \"Desktop ready\"-ForegroundColor green\n\n# Load remote sources with full trust\n$ConfigFilePath = ${Env:ProgramFiles(x86)} + \"\\Microsoft Visual Studio 12.0\\Common7\\IDE\\CommonExtensions\\Microsoft\\TestWindow\\vstest.console.exe.config\"\n[xml]$Configuration = Get-Content -Path $ConfigFilePath\n$element = $Configuration.CreateElement('loadFromRemoteSources')\n$element.Attributes.Append($Configuration.CreateAttribute(\"enabled\"))\n$element.enabled = \"true\"\n$Configuration.configuration.runtime.AppendChild($element)\n$Configuration.Save($ConfigFilePath)\n\n# $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"
assembly_info:
  patch: true
  file: src\CommonAssemblyInfo.cs
  assembly_version: '{version}.0'
  assembly_file_version: '{version}.0'
  assembly_informational_version: '{version}-beta'
install:
- cmd: >-
    REM Apply low integrity label on html files to mark them as accessible from an Enhanced Protected Mode process

    REM http://blogs.msdn.com/b/ieinternals/archive/2012/06/20/loading-local-files-in-enhanced-protected-mode-in-internet-explorer-10.aspx

    REM This circumvents the "Open File - Security Warning" dialog that appears when exes (applications under test) are launched

    icacls "%appveyor_build_folder%" /setintegritylevel (CI)(OI)Medium
nuget:
  disable_publish_on_pr: true
build_script:
- cmd: >-
    setx see_mask_nozonechecks 1 /m

    call "%VS140COMNTOOLS%VsDevCmd.bat"

    msbuild.exe src\build.proj /t:Build;Pack;BuildSilverlight;PackSilverlight


    REM icacls src\Sut.HtmlTest\bin\Release\TestHtmlPage.html /setintegritylevel (CI)(OI)Low
test:
  assemblies: '**\bin\Release\*Test.dll'
artifacts:
- path: '*.nupkg'
  name: NuGet
deploy:
- provider: NuGet
  api_key:
    secure: g78LUTxqGPAeE0eliIasoLHL2fGxcWkPcojy06FwWUqtRUK3E4ToYSQ34GlEUYj5
  artifact: NuGet
on_finish:
- ps: >-
    # Collect test results

    Write-Host "Publishing test results..."

    Get-ChildItem '.\TestResults\*\In' -Recurse -Include '*.*' | % { Push-AppveyorArtifact $_.FullName -FileName $(-Join $(Split-Path (Split-Path (Split-Path $_.FullName -Parent) -Parent ) -Leaf) + '_' + $_.Name) -DeploymentName TestResult }


    # Collect UI test log

    Write-Host "Publishing UI test log..."

    Push-AppveyorArtifact $env:temp\UITestLogs\LastRun\UITestLog.html -DeploymentName UITestLog


    # Allow Remote Desktop

    # $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))


    Write-Host "Build finished."